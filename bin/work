#!/bin/bash
# Interactive work item selector
# Usage: work
#
# Lists current work items: Shortcut stories, git branches, worktrees, PRs, and tmux sessions
# Fetches Shortcut story details for all branches (parallel, ~30-40s for many branches)
#
# TODO:
# - [x] Show PR CI status (currently only shows review status)
# - [x] Show branch name instead of "yes" (for searchability)
# - [x] Fetch titles for all stories, not just those with active sessions
# - [ ] Combine Shortcut and non-Shortcut branches into one unified list
# - [ ] Add fzf integration for interactive selection
# - [ ] Implement selection actions (switch session, create worktree, etc.)

set -euo pipefail

#######################################
# Data Collection
#######################################

get_local_branches() {
    git branch --format='%(refname:short)' 2>/dev/null || true
}

get_worktrees() {
    git worktree list --porcelain 2>/dev/null || true
}

get_github_prs() {
    gh pr list --author="@me" --state=open \
        --json number,headRefName,isDraft,reviewDecision,statusCheckRollup \
        2>/dev/null || echo "[]"
}

get_tmux_sessions() {
    tmux list-sessions -F '#{session_name}' 2>/dev/null || true
}

#######################################
# Helpers
#######################################

extract_story_id() {
    local input="$1"
    if [[ "$input" =~ sc-([0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

# Get current repo name for matching tmux sessions
get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo ""
}

#######################################
# Main
#######################################

main() {
    # Verify we're in a git repo
    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi

    local repo_name
    repo_name=$(get_repo_name)

    # Collect git and tmux data (fast)
    local branches worktrees prs sessions
    branches=$(get_local_branches)
    worktrees=$(get_worktrees)
    prs=$(get_github_prs)
    sessions=$(get_tmux_sessions)

    # Filter sessions for this repo
    local repo_sessions
    repo_sessions=$(echo "$sessions" | grep "^${repo_name}" || true)

    # Extract unique story IDs from ALL branches
    local all_story_ids=""
    while IFS= read -r branch; do
        [ -z "$branch" ] && continue
        local sid
        sid=$(extract_story_id "$branch")
        if [ -n "$sid" ]; then
            if [[ ! "$all_story_ids" =~ (^|$'\n')"$sid"($'\n'|$) ]]; then
                all_story_ids="${all_story_ids}${all_story_ids:+$'\n'}${sid}"
            fi
        fi
    done <<< "$branches"

    # Fetch story details for all stories (parallel, batched)
    local stories_json="[]"
    if [ -n "$all_story_ids" ]; then
        local tmpdir
        tmpdir=$(mktemp -d)
        trap "rm -rf $tmpdir" EXIT

        # Fetch in parallel batches of 30
        local count=0
        local pids=""
        while IFS= read -r sid; do
            [ -z "$sid" ] && continue
            (short story "$sid" --format "%j" 2>/dev/null > "$tmpdir/$sid.json" || echo "{}" > "$tmpdir/$sid.json") &
            pids="$pids $!"
            count=$((count + 1))
            if [ $count -ge 30 ]; then
                wait $pids 2>/dev/null
                pids=""
                count=0
            fi
        done <<< "$all_story_ids"

        if [ -n "$pids" ]; then
            wait $pids 2>/dev/null
        fi

        find "$tmpdir" -name '*.json' -exec cat {} + 2>/dev/null | jq -s '[.[] | select(. != {} and .id != null)]' > "$tmpdir/stories.json" || echo "[]" > "$tmpdir/stories.json"
    else
        tmpdir=$(mktemp -d)
        trap "rm -rf $tmpdir" EXIT
        echo "[]" > "$tmpdir/stories.json"
    fi

    # Write other JSON data to temp files (avoids "Argument list too long")
    echo "$branches" | jq -R -s 'split("\n") | map(select(length > 0))' > "$tmpdir/branches.json"

    echo "$worktrees" | awk '
        /^worktree / { path = substr($0, 10) }
        /^branch / {
            branch = substr($0, 8)
            gsub(/refs\/heads\//, "", branch)
            print path "\t" branch
        }
    ' | jq -R -s 'split("\n") | map(select(length > 0) | split("\t") | {path: .[0], branch: .[1]})' > "$tmpdir/worktrees.json"

    echo "$repo_sessions" | jq -R -s 'split("\n") | map(select(length > 0))' > "$tmpdir/sessions.json" 2>/dev/null || echo "[]" > "$tmpdir/sessions.json"

    echo "$prs" > "$tmpdir/prs.json"

    # Build the correlated work items using jq with slurpfile
    local output
    output=$(jq -n \
        --slurpfile stories "$tmpdir/stories.json" \
        --slurpfile branches "$tmpdir/branches.json" \
        --slurpfile worktrees "$tmpdir/worktrees.json" \
        --slurpfile prs "$tmpdir/prs.json" \
        --slurpfile sessions "$tmpdir/sessions.json" \
        --arg repo "$repo_name" \
    '($stories[0]) as $stories | ($branches[0]) as $branches | ($worktrees[0]) as $worktrees | ($prs[0]) as $prs | ($sessions[0]) as $sessions |
    # Helper to extract story ID from string
    def extract_story_id:
        if test("sc-[0-9]+") then
            capture("sc-(?<id>[0-9]+)") | .id
        else
            null
        end;

    # Helper to derive CI status from statusCheckRollup
    # Handles both CheckRun (GitHub Actions) and StatusContext (CircleCI)
    def ci_status:
        (.statusCheckRollup // []) as $checks |
        if ($checks | length) == 0 then null
        elif ($checks | any(
            (.conclusion == "FAILURE" or .conclusion == "ERROR" or .conclusion == "TIMED_OUT") or
            (.state == "FAILURE" or .state == "ERROR")
        )) then "failing"
        elif ($checks | any(
            (.status != null and .status != "COMPLETED") or
            (.state == "PENDING")
        )) then "pending"
        else "passing"
        end;

    # Helper to derive review status
    def review_status:
        if .isDraft then "draft"
        elif .reviewDecision == "APPROVED" then "approved"
        elif .reviewDecision == "CHANGES_REQUESTED" then "changes"
        elif .reviewDecision == "REVIEW_REQUIRED" then "needs review"
        else null
        end;

    # Combined PR status: #12345 (passing, needs review)
    def pr_display:
        .number as $num |
        (ci_status) as $ci |
        (review_status) as $review |
        [($ci // empty), ($review // empty)] |
        if length == 0 then "#\($num)"
        else "#\($num) (\(join(", ")))"
        end;

    # Build lookup maps
    ($worktrees | map({(.branch): .path}) | add // {}) as $worktree_map |
    ($prs | map({(.headRefName): .}) | add // {}) as $pr_map |
    ($stories | map({(.id | tostring): .name}) | add // {}) as $story_names |

    # Build items for branches with sc- pattern
    ($branches | map(select(test("sc-[0-9]+"))) | map(
        . as $branch |
        ($branch | extract_story_id) as $story_id |
        ($sessions | map(select(. as $s | ($s | extract_story_id) == $story_id)) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            story_id: $story_id,
            title: ($story_names[$story_id] // "-"),
            branch: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    ) | unique_by(.story_id)) as $story_items |

    # Find non-shortcut branches (those without sc- pattern)
    ($branches | map(select(extract_story_id == null)) | map(
        . as $branch |
        ($sessions | map(select(. | contains($branch))) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            branch_name: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    )) as $other_items |

    {
        stories: ($story_items | sort_by(.session) | reverse),
        other: $other_items
    }
    ')

    # Format and print the Shortcut stories table
    local story_count
    story_count=$(echo "$output" | jq '.stories | length')

    if [ "$story_count" -gt 0 ]; then
        {
            printf "SESSION\tSTORY\tTITLE\tBRANCH\tWT\tPR\n"
            echo "$output" | jq -r '.stories[] | [.session, .story_id, (if .title == "-" then "-" elif (.title | length) > 45 then (.title[:42] + "...") else .title end), .branch, .worktree, .pr] | @tsv'
        } | column -t -s $'\t'
    else
        echo "No Shortcut stories found (no sc-* branches)"
    fi

    # Format and print the other branches table
    local other_count
    other_count=$(echo "$output" | jq '.other | length')

    if [ "$other_count" -gt 0 ]; then
        echo ""
        echo "Other branches:"
        {
            printf "SESSION\tBRANCH\tWT\tPR\n"
            echo "$output" | jq -r '.other[] | [.session, .branch_name, .worktree, .pr] | @tsv'
        } | column -t -s $'\t'
    fi
}

main "$@"
