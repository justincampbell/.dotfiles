#!/bin/bash
# Interactive work item selector
# Usage: work
#
# Lists current work items: Shortcut stories, git branches, worktrees, PRs, and tmux sessions
# Fetches Shortcut story details via bulk API (~1-2s for all stories)
#
# TODO:
# - [x] Show PR CI status (currently only shows review status)
# - [x] Show branch name instead of "yes" (for searchability)
# - [x] Fetch titles for all stories, not just those with active sessions
# - [x] Combine Shortcut and non-Shortcut branches into one unified list
# - [x] Optimize Shortcut API usage (bulk API with pagination, 30-45s -> 2s)
# - [ ] Add fzf integration for interactive selection
# - [ ] Implement selection actions (switch session, create worktree, etc.)

set -euo pipefail

#######################################
# Data Collection
#######################################

get_local_branches() {
    git branch --format='%(refname:short)' 2>/dev/null || true
}

get_worktrees() {
    git worktree list --porcelain 2>/dev/null || true
}

get_github_prs() {
    gh pr list --author="@me" --state=open \
        --json number,headRefName,isDraft,reviewDecision,statusCheckRollup \
        2>/dev/null || echo "[]"
}

get_tmux_sessions() {
    tmux list-sessions -F '#{session_name}' 2>/dev/null || true
}

#######################################
# Helpers
#######################################

extract_story_id() {
    local input="$1"
    if [[ "$input" =~ sc-([0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

# Get current repo name for matching tmux sessions
get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo ""
}

#######################################
# Main
#######################################

main() {
    # Verify we're in a git repo
    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi

    local repo_name
    repo_name=$(get_repo_name)

    # Collect git and tmux data (fast)
    local branches worktrees prs sessions
    branches=$(get_local_branches)
    worktrees=$(get_worktrees)
    prs=$(get_github_prs)
    sessions=$(get_tmux_sessions)

    # Filter sessions for this repo
    local repo_sessions
    repo_sessions=$(echo "$sessions" | grep "^${repo_name}" || true)

    # Setup temp directory
    local tmpdir
    tmpdir=$(mktemp -d)
    trap 'rm -rf "${tmpdir:-}"' EXIT

    # Fetch all stories owned by user via bulk API (much faster than individual fetches)
    if ! command -v short >/dev/null 2>&1; then
        echo "Warning: 'short' command not found, story titles will not be available" >&2
        echo "[]" > "$tmpdir/stories.json"
    else
        local mention_name
        mention_name=$(short api /member 2>/dev/null | jq -r '.mention_name')

        if [ -z "$mention_name" ] || [ "$mention_name" = "null" ]; then
            echo "Warning: Could not get Shortcut mention_name, story titles will not be available" >&2
            echo "[]" > "$tmpdir/stories.json"
        else
            # Paginate through all stories with page_size=100 for efficiency
            local url="/search/stories?query=owner:$mention_name&page_size=100"
            local all_stories="[]"
            local max_pages=50
            local page=0

            while [ -n "$url" ] && [ $page -lt $max_pages ]; do
                page=$((page + 1))
                local response
                response=$(short api "$url" 2>/dev/null || echo '{"data":[]}')

                # Append this page's data to all_stories
                all_stories=$(jq -s '.[0] + .[1].data' <<< "$all_stories"$'\n'"$response")

                # Get next URL, or empty if done
                url=$(echo "$response" | jq -r '.next // empty' | sed 's|^/api/v3||')
            done

            if [ $page -ge $max_pages ]; then
                echo "Warning: Reached maximum page limit ($max_pages)" >&2
            fi

            echo "$all_stories" > "$tmpdir/stories.json"
        fi
    fi

    # Write other JSON data to temp files (avoids "Argument list too long")
    echo "$branches" | jq -R -s 'split("\n") | map(select(length > 0))' > "$tmpdir/branches.json"

    echo "$worktrees" | awk '
        /^worktree / { path = substr($0, 10) }
        /^branch / {
            branch = substr($0, 8)
            gsub(/refs\/heads\//, "", branch)
            print path "\t" branch
        }
    ' | jq -R -s 'split("\n") | map(select(length > 0) | split("\t") | {path: .[0], branch: .[1]})' > "$tmpdir/worktrees.json"

    echo "$repo_sessions" | jq -R -s 'split("\n") | map(select(length > 0))' > "$tmpdir/sessions.json" 2>/dev/null || echo "[]" > "$tmpdir/sessions.json"

    echo "$prs" > "$tmpdir/prs.json"

    # Build the correlated work items using jq with slurpfile
    local output
    output=$(jq -n \
        --slurpfile stories "$tmpdir/stories.json" \
        --slurpfile branches "$tmpdir/branches.json" \
        --slurpfile worktrees "$tmpdir/worktrees.json" \
        --slurpfile prs "$tmpdir/prs.json" \
        --slurpfile sessions "$tmpdir/sessions.json" \
        --arg repo "$repo_name" \
    '($stories[0]) as $stories | ($branches[0]) as $branches | ($worktrees[0]) as $worktrees | ($prs[0]) as $prs | ($sessions[0]) as $sessions |
    # Helper to extract story ID from string
    def extract_story_id:
        if test("sc-[0-9]+") then
            capture("sc-(?<id>[0-9]+)") | .id
        else
            null
        end;

    # Helper to derive CI status from statusCheckRollup
    # Handles both CheckRun (GitHub Actions) and StatusContext (CircleCI)
    def ci_status:
        (.statusCheckRollup // []) as $checks |
        if ($checks | length) == 0 then null
        elif ($checks | any(
            (.conclusion == "FAILURE" or .conclusion == "ERROR" or .conclusion == "TIMED_OUT") or
            (.state == "FAILURE" or .state == "ERROR")
        )) then "âŒ"
        elif ($checks | any(
            (.status != null and .status != "COMPLETED") or
            (.state == "PENDING")
        )) then "â³"
        else "âœ…"
        end;

    # Helper to derive review status
    def review_status:
        if .isDraft then "ðŸ“"
        elif .reviewDecision == "APPROVED" then "âœ“"
        elif .reviewDecision == "CHANGES_REQUESTED" then "âš ï¸"
        elif .reviewDecision == "REVIEW_REQUIRED" then "ðŸ‘€"
        else null
        end;

    # Combined PR status: #12345 âœ… ðŸ‘€
    def pr_display:
        .number as $num |
        (ci_status) as $ci |
        (review_status) as $review |
        [($ci // empty), ($review // empty)] |
        if length == 0 then "#\($num)"
        elif length == 1 then "#\($num) \(.[0])"
        else "#\($num) \(.[0]) \(.[1])"
        end;

    # Build lookup maps
    ($worktrees | map({(.branch): .path}) | add // {}) as $worktree_map |
    ($prs | map({(.headRefName): .}) | add // {}) as $pr_map |
    ($stories | map({(.id | tostring): .name}) | add // {}) as $story_names |

    # Build items for branches with sc- pattern
    ($branches | map(select(test("sc-[0-9]+"))) | map(
        . as $branch |
        ($branch | extract_story_id) as $story_id |
        ($sessions | map(select(. as $s | ($s | extract_story_id) == $story_id)) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            story_id: $story_id,
            title: ($story_names[$story_id] // "-"),
            branch: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            pr_obj: $pr,
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    ) | unique_by(.story_id)) as $story_items |

    # Find non-shortcut branches (those without sc- pattern)
    ($branches | map(select(extract_story_id == null)) | map(
        . as $branch |
        ($sessions | map(select(. | contains($branch))) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            story_id: "-",
            title: "-",
            branch: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            pr_obj: $pr,
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    )) as $other_items |

    # Combine and sort by priority, then story_id descending
    # Priority: 1=active sessions, 2=PRs needing attention, 3=PRs ready to merge,
    #           4=PRs in review, 5=other PR states, 6=worktrees, 7=everything else
    ($story_items + $other_items) | map(
        . as $item |
        if $item.session == "*" then $item + {priority: 1}
        elif ($item.pr_obj != null) then
            ($item.pr_obj | ci_status) as $ci |
            ($item.pr_obj | review_status) as $review |
            if ($ci == "âŒ" or $review == "âš ï¸") then $item + {priority: 2}
            elif ($ci == "âœ…" and $review == "âœ“") then $item + {priority: 3}
            elif ($ci == "âœ…" and $review == "ðŸ‘€") then $item + {priority: 4}
            else $item + {priority: 5}
            end
        elif $item.worktree == "yes" then $item + {priority: 6}
        else $item + {priority: 7}
        end
    ) | sort_by([.priority, -(.story_id | if . == "-" then 0 else tonumber end)])
    ')

    # Format and print unified table
    local item_count
    item_count=$(echo "$output" | jq 'length')

    if [ "$item_count" -gt 0 ]; then
        # Get terminal width - try multiple methods
        local term_width
        term_width=${COLUMNS:-}
        [ -z "$term_width" ] && term_width=$(stty size 2>/dev/null | cut -d' ' -f2)
        [ -z "$term_width" ] && term_width=$(tput cols 2>/dev/null)
        [ -z "$term_width" ] && term_width=120

        # Calculate natural max widths for ALL columns from actual data
        # Note: Emoji take 2 visual cells but count as 1 char, so we calculate visual width for PR column
        local max_session max_story max_title max_branch max_wt max_pr
        read -r max_session max_story max_title max_branch max_wt max_pr <<< "$(echo "$output" | jq -r '
            def visual_length:
                . as $str |
                ($str | length) as $len |
                # Count emoji (rough heuristic: count common emoji we use)
                ($str | [match("âœ…|âŒ|â³|âœ“|ðŸ“|âš ï¸|ðŸ‘€"; "g")] | length) as $emoji_count |
                $len + $emoji_count;  # Add 1 extra width per emoji (since they take 2 cells but count as 1)

            [
                (["SESSION", (.[].session)] | map(length) | max),
                (["STORY", (.[].story_id | tostring)] | map(length) | max),
                (["TITLE", (.[].title)] | map(length) | max),
                (["BRANCH", (.[].branch)] | map(length) | max),
                (["WT", (.[].worktree)] | map(length) | max),
                (["PR", (.[].pr)] | map(visual_length) | max)
            ] | @tsv
        ')"

        # Calculate natural width with 2-space separators between 6 columns = 10 spaces
        local natural_width=$((max_session + max_story + max_title + max_branch + max_wt + max_pr + 10))

        # Only truncate TITLE and BRANCH if natural width exceeds terminal
        local title_width=$max_title
        local branch_width=$max_branch

        if [ $natural_width -gt $term_width ]; then
            # Need to truncate - calculate available space for TITLE and BRANCH
            local fixed_width=$((max_session + max_story + max_wt + max_pr + 10))
            local available=$((term_width - fixed_width))

            # Split available space 50/50 between TITLE and BRANCH
            title_width=$((available * 50 / 100))
            branch_width=$((available * 50 / 100))
        fi

        {
            printf "SESSION\tSTORY\tTITLE\tBRANCH\tWT\tPR\n"
            echo "$output" | jq -r --argjson tw "$title_width" --argjson bw "$branch_width" '.[] | [
                .session,
                .story_id,
                (if .title == "-" then "-" elif (.title | length) > $tw then (.title[:($tw - 3)] + "...") else .title end),
                (if (.branch | length) > $bw then (.branch[:($bw - 3)] + "...") else .branch end),
                .worktree,
                .pr
            ] | @tsv'
        } | column -t -s $'\t'
    else
        echo "No branches found"
    fi
}

main "$@"
