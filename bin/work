#!/bin/bash
# Interactive work item selector
# Usage: work
#
# Lists current work items: Shortcut stories, git branches, worktrees, PRs, and tmux sessions
# Only fetches Shortcut story details for active tmux sessions (fast)
#
# TODO:
# - [x] Show PR CI status (currently only shows review status)
# - [x] Show branch name instead of "yes" (for searchability)
# - [ ] Fetch titles for all stories, not just those with active sessions
# - [ ] Combine Shortcut and non-Shortcut branches into one unified list
# - [ ] Add fzf integration for interactive selection
# - [ ] Implement selection actions (switch session, create worktree, etc.)

set -euo pipefail

#######################################
# Data Collection
#######################################

get_local_branches() {
    git branch --format='%(refname:short)' 2>/dev/null || true
}

get_worktrees() {
    git worktree list --porcelain 2>/dev/null || true
}

get_github_prs() {
    gh pr list --author="@me" --state=open \
        --json number,headRefName,isDraft,reviewDecision,statusCheckRollup \
        2>/dev/null || echo "[]"
}

get_tmux_sessions() {
    tmux list-sessions -F '#{session_name}' 2>/dev/null || true
}

#######################################
# Helpers
#######################################

extract_story_id() {
    local input="$1"
    if [[ "$input" =~ sc-([0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    fi
}

# Get current repo name for matching tmux sessions
get_repo_name() {
    basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo ""
}

#######################################
# Main
#######################################

main() {
    # Verify we're in a git repo
    if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi

    local repo_name
    repo_name=$(get_repo_name)

    # Collect git and tmux data (fast)
    local branches worktrees prs sessions
    branches=$(get_local_branches)
    worktrees=$(get_worktrees)
    prs=$(get_github_prs)
    sessions=$(get_tmux_sessions)

    # Filter sessions for this repo
    local repo_sessions
    repo_sessions=$(echo "$sessions" | grep "^${repo_name}" || true)

    # Extract story IDs from active tmux sessions only (fast path - only fetch these)
    local active_story_ids=""
    while IFS= read -r session; do
        [ -z "$session" ] && continue
        local sid
        sid=$(extract_story_id "$session")
        if [ -n "$sid" ]; then
            if [[ ! "$active_story_ids" =~ (^|$'\n')"$sid"($'\n'|$) ]]; then
                active_story_ids="${active_story_ids}${active_story_ids:+$'\n'}${sid}"
            fi
        fi
    done <<< "$repo_sessions"

    # Fetch story details only for active sessions (parallel, fast)
    local stories_json="[]"
    if [ -n "$active_story_ids" ]; then
        local tmpdir
        tmpdir=$(mktemp -d)
        trap "rm -rf $tmpdir" EXIT

        local pids=""
        while IFS= read -r sid; do
            [ -z "$sid" ] && continue
            (short story "$sid" --format "%j" 2>/dev/null > "$tmpdir/$sid.json" || echo "{}" > "$tmpdir/$sid.json") &
            pids="$pids $!"
        done <<< "$active_story_ids"

        if [ -n "$pids" ]; then
            wait $pids
        fi

        stories_json=$(cat "$tmpdir"/*.json 2>/dev/null | jq -s '[.[] | select(. != {} and .id != null)]' || echo "[]")
    fi

    # Convert branches to JSON array
    local branches_json
    branches_json=$(echo "$branches" | jq -R -s 'split("\n") | map(select(length > 0))')

    # Parse worktrees into JSON array of {path, branch}
    local worktrees_json
    worktrees_json=$(echo "$worktrees" | awk '
        /^worktree / { path = substr($0, 10) }
        /^branch / {
            branch = substr($0, 8)
            gsub(/refs\/heads\//, "", branch)
            print path "\t" branch
        }
    ' | jq -R -s 'split("\n") | map(select(length > 0) | split("\t") | {path: .[0], branch: .[1]})')

    # Convert sessions to JSON array (only matching repo)
    local sessions_json
    sessions_json=$(echo "$repo_sessions" | jq -R -s 'split("\n") | map(select(length > 0))' 2>/dev/null || echo "[]")

    # Build the correlated work items using jq
    local output
    output=$(jq -n \
        --argjson stories "$stories_json" \
        --argjson branches "$branches_json" \
        --argjson worktrees "$worktrees_json" \
        --argjson prs "$prs" \
        --argjson sessions "$sessions_json" \
        --arg repo "$repo_name" \
    '
    # Helper to extract story ID from string
    def extract_story_id:
        if test("sc-[0-9]+") then
            capture("sc-(?<id>[0-9]+)") | .id
        else
            null
        end;

    # Helper to derive CI status from statusCheckRollup
    # Handles both CheckRun (GitHub Actions) and StatusContext (CircleCI)
    def ci_status:
        (.statusCheckRollup // []) as $checks |
        if ($checks | length) == 0 then null
        elif ($checks | any(
            (.conclusion == "FAILURE" or .conclusion == "ERROR" or .conclusion == "TIMED_OUT") or
            (.state == "FAILURE" or .state == "ERROR")
        )) then "failing"
        elif ($checks | any(
            (.status != null and .status != "COMPLETED") or
            (.state == "PENDING")
        )) then "pending"
        else "passing"
        end;

    # Helper to derive review status
    def review_status:
        if .isDraft then "draft"
        elif .reviewDecision == "APPROVED" then "approved"
        elif .reviewDecision == "CHANGES_REQUESTED" then "changes"
        elif .reviewDecision == "REVIEW_REQUIRED" then "needs review"
        else null
        end;

    # Combined PR status: #12345 (passing, needs review)
    def pr_display:
        .number as $num |
        (ci_status) as $ci |
        (review_status) as $review |
        [($ci // empty), ($review // empty)] |
        if length == 0 then "#\($num)"
        else "#\($num) (\(join(", ")))"
        end;

    # Build lookup maps
    ($worktrees | map({(.branch): .path}) | add // {}) as $worktree_map |
    ($prs | map({(.headRefName): .}) | add // {}) as $pr_map |
    ($stories | map({(.id | tostring): .name}) | add // {}) as $story_names |

    # Build items for branches with sc- pattern
    ($branches | map(select(test("sc-[0-9]+"))) | map(
        . as $branch |
        ($branch | extract_story_id) as $story_id |
        ($sessions | map(select(. as $s | ($s | extract_story_id) == $story_id)) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            story_id: $story_id,
            title: ($story_names[$story_id] // "-"),
            branch: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    ) | unique_by(.story_id)) as $story_items |

    # Find non-shortcut branches (those without sc- pattern)
    ($branches | map(select(extract_story_id == null)) | map(
        . as $branch |
        ($sessions | map(select(. | contains($branch))) | first // null) as $session |
        ($pr_map[$branch] // null) as $pr |
        {
            branch_name: $branch,
            worktree: (if $worktree_map[$branch] then "yes" else "no" end),
            pr: (if $pr then ($pr | pr_display) else "-" end),
            session: (if $session then "*" else " " end),
            session_name: $session
        }
    )) as $other_items |

    {
        stories: ($story_items | sort_by(.session) | reverse),
        other: $other_items
    }
    ')

    # Format and print the Shortcut stories table
    local story_count
    story_count=$(echo "$output" | jq '.stories | length')

    if [ "$story_count" -gt 0 ]; then
        {
            printf "SESSION\tSTORY\tTITLE\tBRANCH\tWT\tPR\n"
            echo "$output" | jq -r '.stories[] | [.session, .story_id, (if .title == "-" then "-" elif (.title | length) > 45 then (.title[:42] + "...") else .title end), .branch, .worktree, .pr] | @tsv'
        } | column -t -s $'\t'
    else
        echo "No Shortcut stories found (no sc-* branches)"
    fi

    # Format and print the other branches table
    local other_count
    other_count=$(echo "$output" | jq '.other | length')

    if [ "$other_count" -gt 0 ]; then
        echo ""
        echo "Other branches:"
        {
            printf "SESSION\tBRANCH\tWT\tPR\n"
            echo "$output" | jq -r '.other[] | [.session, .branch_name, .worktree, .pr] | @tsv'
        } | column -t -s $'\t'
    fi
}

main "$@"
